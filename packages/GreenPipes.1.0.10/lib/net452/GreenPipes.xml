<?xml version="1.0"?>
<doc>
    <assembly>
        <name>GreenPipes</name>
    </assembly>
    <members>
        <member name="T:GreenPipes.BasePipeContext">
            <summary>
            The base for a pipe context, with the underlying support for managing paylaods (out-of-band data
            that is carried along with the context).
            </summary>
        </member>
        <member name="M:GreenPipes.BasePipeContext.#ctor">
            <summary>
            A new pipe context with an existing payload cache -- includes a new CancellationTokenSource. If 
            cancellation is not supported, use the above constructor with CancellationToken.None to avoid
            creating a token source.
            </summary>
        </member>
        <member name="M:GreenPipes.BasePipeContext.#ctor(GreenPipes.Payloads.IPayloadCache)">
            <summary>
            A new pipe context with an existing payload cache -- includes a new CancellationTokenSource. If 
            cancellation is not supported, use the above constructor with CancellationToken.None to avoid
            creating a token source.
            </summary>
            <param name="payloadCache"></param>
        </member>
        <member name="M:GreenPipes.BasePipeContext.#ctor(GreenPipes.Payloads.IPayloadCache,System.Threading.CancellationToken)">
            <summary>
            Uses the specified payloadCache and cancellationToken for the context
            </summary>
            <param name="payloadCache">A payload cache</param>
            <param name="cancellationToken">A cancellation token</param>
        </member>
        <member name="M:GreenPipes.BasePipeContext.#ctor(GreenPipes.PipeContext)">
            <summary>
            A new pipe context based off an existing pipe context, which delegates the payloadCache
            to the existing pipe context.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:GreenPipes.BasePipeContext.CancellationToken">
            <summary>
            Returns the CancellationToken for the context (implicit interface)
            </summary>
        </member>
        <member name="M:GreenPipes.BasePipeContext.HasPayloadType(System.Type)">
            <summary>
            Returns true if the payload type is included with or supported by the context type
            </summary>
            <param name="payloadType"></param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.BasePipeContext.TryGetPayload``1(``0@)">
            <summary>
            Attemts 
            </summary>
            <param name="payload"></param>
            <typeparam name="TPayload"></typeparam>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.BasePipeContext.GetOrAddPayload``1(GreenPipes.PayloadFactory{``0})">
            <summary>
            Get or add a payload to the context, using the provided payload factory.
            </summary>
            <param name="payloadFactory">The payload factory, which is only invoked if the payload is not present.</param>
            <typeparam name="TPayload">The payload type</typeparam>
            <returns></returns>
        </member>
        <member name="T:GreenPipes.BindContext`2">
            <summary>
            The binding of a value to the context, which is a fancy form of Tuple
            </summary>
            <typeparam name="TContext"></typeparam>
            <typeparam name="TTarget"></typeparam>
        </member>
        <member name="P:GreenPipes.BindContext`2.Context">
            <summary>
            The original context
            </summary>
        </member>
        <member name="P:GreenPipes.BindContext`2.Target">
            <summary>
            The bound target
            </summary>
        </member>
        <member name="M:GreenPipes.ConcurrencyLimitExtensions.SetConcurrencyLimit(GreenPipes.IPipe{GreenPipes.Contracts.CommandContext},System.Int32)">
            <summary>
            Set the concurrency limit of the filter
            </summary>
            <param name="pipe"></param>
            <param name="concurrencyLimit"></param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.BindConfigurationExtensions.UseBind``1(GreenPipes.IPipeConfigurator{``0},System.Action{GreenPipes.Configurators.IBindConfigurator{``0}})">
            <summary>
            Adds a filter to the pipe which is of a different type than the native pipe context type
            </summary>
            <typeparam name="TContext">The context type</typeparam>
            <param name="configurator">The pipe configurator</param>
            <param name="configure"></param>
        </member>
        <member name="M:GreenPipes.Builders.IBuildPipeConfigurator`1.Build">
            <summary>
            Builds the pipe, applying any initial specifications to the front of the pipe
            </summary>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.Builders.IBuildRequestPipeConfigurator`2.Build(GreenPipes.IPipe{GreenPipes.ResultContext})">
            <summary>
            Builds the pipe, applying any initial specifications to the front of the pipe
            </summary>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.Builders.IBuildResultPipeConfigurator`2.Build">
            <summary>
            Builds the pipe, applying any initial specifications to the front of the pipe
            </summary>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.CircuitBreakerConfigurationExtensions.UseCircuitBreaker``1(GreenPipes.IPipeConfigurator{``0},System.Action{GreenPipes.Configurators.ICircuitBreakerConfigurator{``0}})">
            <summary>
            Puts a circuit breaker in the pipe, which can automatically prevent the flow of messages to the consumer
            when the circuit breaker is opened.
            </summary>
            <typeparam name="T">The pipe context type</typeparam>
            <param name="configurator"></param>
            <param name="configure"></param>
        </member>
        <member name="M:GreenPipes.ConcurrencyLimitConfigurationExtensions.UseConcurrencyLimit``1(GreenPipes.IPipeConfigurator{``0},System.Int32,GreenPipes.IPipeRouter)">
            <summary>
            Specify a concurrency limit for tasks executing through the filter. No more than the specified
            number of tasks will be allowed to execute concurrently.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="configurator"></param>
            <param name="concurrencyLimit">The concurrency limit for the subsequent filters in the pipeline</param>
            <param name="router">A control pipe to support runtime adjustment</param>
        </member>
        <member name="P:GreenPipes.Configurators.IBindConfigurator`2.ContextPipe">
            <summary>
            Configure a filter on the context pipe, versus the bound pipe
            </summary>
        </member>
        <member name="T:GreenPipes.Configurators.ICircuitBreakerConfigurator`1">
            <summary>
            Configure the settings on the circuit breaker
            </summary>
            <typeparam name="TContext"></typeparam>
        </member>
        <member name="P:GreenPipes.Configurators.ICircuitBreakerConfigurator`1.TrackingPeriod">
            <summary>
            The period after which the attempt/failure counts are reset.
            </summary>
        </member>
        <member name="P:GreenPipes.Configurators.ICircuitBreakerConfigurator`1.TripThreshold">
            <summary>
            The percentage of attempts that must fail before the circuit breaker trips into
            an open state.
            </summary>
        </member>
        <member name="P:GreenPipes.Configurators.ICircuitBreakerConfigurator`1.ActiveThreshold">
            <summary>
            The number of attempts that must occur before the circuit breaker becomes active. Until the
            breaker activates, it will not open on failure
            </summary>
        </member>
        <member name="P:GreenPipes.Configurators.ICircuitBreakerConfigurator`1.ResetInterval">
            <summary>
            Sets a specific reset interval for the circuit to attempt to close after being tripped.
            By default, this is an incrementing scale up to one minute.
            </summary>
            <value></value>
        </member>
        <member name="P:GreenPipes.Configurators.ICircuitBreakerConfigurator`1.Router">
            <summary>
            Configure a router for sending events from the circuit breaker
            </summary>
        </member>
        <member name="T:GreenPipes.Configurators.IRequestConfigurator">
            <summary>
            Configure a request, specifying the responses and their pipes
            </summary>
        </member>
        <member name="M:GreenPipes.Configurators.IRequestConfigurator.Request``2(System.Action{GreenPipes.Configurators.IResultConfigurator{``0,``1}})">
            <summary>
            Create a pipe that handles a request with a single response
            </summary>
            <typeparam name="TRequest"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="configureRequest"></param>
            <returns></returns>
        </member>
        <member name="T:GreenPipes.Configurators.IRequestConfigurator`1">
            <summary>
            Configure a request, specifying the responses and their pipes
            </summary>
            <typeparam name="TRequest"></typeparam>
        </member>
        <member name="M:GreenPipes.Configurators.IRequestConfigurator`1.Result``1(System.Action{GreenPipes.Configurators.IRequestConfigurator{`0,``0}})">
            <summary>
            Declares a result for the request which can be set by a service
            </summary>
            <typeparam name="TResult">The result type</typeparam>
            <param name="configure">Configure the result pipe</param>
            <returns></returns>
        </member>
        <member name="T:GreenPipes.Configurators.IRequestConfigurator`2">
            <summary>
            Configure a response pipe, which handles a response from a request pipe
            </summary>
            <typeparam name="TRequest"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="P:GreenPipes.Configurators.IRescueConfigurator`2.ContextPipe">
            <summary>
            Configure a filter on the context pipe, versus the rescue pipe
            </summary>
        </member>
        <member name="T:GreenPipes.Configurators.IResultConfigurator`2">
            <summary>
            Configure a response pipe, which handles a response from a request pipe
            </summary>
            <typeparam name="TRequest"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="T:GreenPipes.Configurators.RequestConfigurator">
            <summary>
            Allows a request type to be specified on the pipe, and the subsequent configuration
            of the response types and response pipes.
            </summary>
        </member>
        <member name="T:GreenPipes.Configurators.RequestConfigurator`2">
            <summary>
            This will become a specification, since the goal is to have everything rally around
            the dispatch pipe
            </summary>
            <typeparam name="TRequest"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="T:GreenPipes.Configurators.ResultConfigurator`2">
            <summary>
            This will become a specification, since the goal is to have everything rally around
            the dispatch pipe
            </summary>
            <typeparam name="TRequest"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:GreenPipes.ContextFilterConfigurationExtensions.UseContextFilter``1(GreenPipes.IPipeConfigurator{``0},System.Func{``0,System.Threading.Tasks.Task{System.Boolean}})">
            <summary>
            Adds a content filter that uses a delegate to filter the context and only accept messages 
            which pass the filter specification.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="configurator"></param>
            <param name="filter">A filter method that returns true to accept the message, or false to discard it</param>
        </member>
        <member name="M:GreenPipes.DelegateConfigurationExtensions.UseExecute``1(GreenPipes.IPipeConfigurator{``0},System.Action{``0})">
            <summary>
            Executes a synchronous method on the pipe
            </summary>
            <typeparam name="TContext">The context type</typeparam>
            <param name="configurator">The pipe configurator</param>
            <param name="callback">The callback to invoke</param>
        </member>
        <member name="M:GreenPipes.DelegateConfigurationExtensions.UseExecuteAsync``1(GreenPipes.IPipeConfigurator{``0},System.Func{``0,System.Threading.Tasks.Task})">
            <summary>
            Executes an asynchronous method on the pipe
            </summary>
            <typeparam name="TContext">The context type</typeparam>
            <param name="configurator">The pipe configurator</param>
            <param name="callback">The callback to invoke</param>
        </member>
        <member name="M:GreenPipes.DispatchConfigurationExtensions.UseDispatch``1(GreenPipes.IPipeConfigurator{``0},GreenPipes.Filters.IPipeContextConverterFactory{``0},System.Action{GreenPipes.Configurators.IDispatchConfigurator{``0}})">
            <summary>
            Adds a dispatch filter to the pipe, which can be used to route traffic
            based on the type of the incoming context
            </summary>
            <typeparam name="T"></typeparam>
            <param name="configurator"></param>
            <param name="pipeContextProviderFactory"></param>
            <param name="configure"></param>
        </member>
        <member name="M:GreenPipes.FilterConfigurationExtensions.UseFilter``1(GreenPipes.IPipeConfigurator{``0},GreenPipes.IFilter{``0})">
            <summary>
            Adds a filter to the pipe
            </summary>
            <typeparam name="T">The context type</typeparam>
            <param name="configurator">The pipe configurator</param>
            <param name="filter">The filter to add</param>
        </member>
        <member name="M:GreenPipes.FilterConfigurationExtensions.UseFilters``1(GreenPipes.IPipeConfigurator{``0},System.Collections.Generic.IEnumerable{GreenPipes.IFilter{``0}})">
            <summary>
            Adds filters to the pipe
            </summary>
            <typeparam name="T">The context type</typeparam>
            <param name="configurator">The pipe configurator</param>
            <param name="filters">The filters to add</param>
        </member>
        <member name="M:GreenPipes.FilterConfigurationExtensions.UseFilters``1(GreenPipes.IPipeConfigurator{``0},GreenPipes.IFilter{``0}[])">
            <summary>
            Adds filters to the pipe
            </summary>
            <typeparam name="T">The context type</typeparam>
            <param name="configurator">The pipe configurator</param>
            <param name="filters">The filters to add</param>
        </member>
        <member name="M:GreenPipes.FilterConfigurationExtensions.UseFilter``2(GreenPipes.IPipeConfigurator{``0},GreenPipes.IFilter{``1},GreenPipes.MergeFilterContextProvider{``0,``1},GreenPipes.FilterContextProvider{``1,``0})">
            <summary>
            Adds a filter to the pipe which is of a different type than the native pipe context type
            </summary>
            <typeparam name="TContext">The context type</typeparam>
            <typeparam name="TFilter">The filter context type</typeparam>
            <param name="configurator">The pipe configurator</param>
            <param name="filter">The filter to add</param>
            <param name="contextProvider"></param>
            <param name="inputContextProvider"></param>
        </member>
        <member name="M:GreenPipes.ForkConfigurationExtensions.UseFork``1(GreenPipes.IPipeConfigurator{``0},GreenPipes.IPipe{``0})">
            <summary>
            Adds a fork to the pipe, which invokes a separate pipe concurrently with the current pipe
            </summary>
            <typeparam name="T">The context type</typeparam>
            <param name="configurator">The pipe configurator</param>
            <param name="pipe">The filter to add</param>
        </member>
        <member name="M:GreenPipes.InlineFilterConfigurationExtensions.UseInlineFilter``1(GreenPipes.IPipeConfigurator{``0},GreenPipes.InlineFilterMethod{``0})">
            <summary>
            Creates an inline filter using a simple async method
            </summary>
            <typeparam name="T">The context type</typeparam>
            <param name="configurator">The pipe configurator</param>
            <param name="inlineFilterMethod">The inline filter delegate</param>
        </member>
        <member name="M:GreenPipes.InterceptConfigurationExtensions.UseIntercept``1(GreenPipes.IPipeConfigurator{``0},GreenPipes.IPipe{``0})">
            <summary>
            Adds a fork to the pipe, which invokes a separate pipe before passing to the next filter.
            </summary>
            <typeparam name="T">The context type</typeparam>
            <param name="configurator">The pipe configurator</param>
            <param name="pipe">The filter to add</param>
        </member>
        <member name="T:GreenPipes.IPipeBuilder`1">
            <summary>
            A pipe builder constructs a pipe by adding filter to the end of the chain, after
            while the builder completes the pipe/filter combination.
            </summary>
            <typeparam name="TContext">The pipe context type</typeparam>
        </member>
        <member name="M:GreenPipes.IPipeBuilder`1.AddFilter(GreenPipes.IFilter{`0})">
            <summary>
            Add a filter to the pipe after any existing filters
            </summary>
            <param name="filter">The filter to add</param>
        </member>
        <member name="T:GreenPipes.IPipeConfigurator`1">
            <summary>
            Configures a pipe with specifications
            </summary>
            <typeparam name="TContext"></typeparam>
        </member>
        <member name="M:GreenPipes.IPipeConfigurator`1.AddPipeSpecification(GreenPipes.IPipeSpecification{`0})">
            <summary>
            Adds a pipe specification to the pipe configurator at the end of the chain
            </summary>
            <param name="specification">The pipe specification to add</param>
        </member>
        <member name="T:GreenPipes.IPipeSpecification`1">
            <summary>
            Configures a pipe builder (typically by adding filters), but allows late binding to the
            pipe builder with pre-validation that the operations will succeed.
            </summary>
            <typeparam name="TContext"></typeparam>
        </member>
        <member name="M:GreenPipes.IPipeSpecification`1.Apply(GreenPipes.IPipeBuilder{`0})">
            <summary>
            Apply the specification to the builder
            </summary>
            <param name="builder">The pipe builder</param>
        </member>
        <member name="T:GreenPipes.ISpecification">
            <summary>
            A specification, that can be validated as part of a configurator, is used
            to allow nesting and chaining of specifications while ensuring that all aspects
            of the configuration are verified correct.
            </summary>
        </member>
        <member name="M:GreenPipes.ISpecification.Validate">
            <summary>
            Validate the specification, ensuring that a successful build will occur.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.PartitionerConfigurationExtensions.CreatePartitioner``1(GreenPipes.IPipeConfigurator{``0},System.Int32)">
            <summary>
            Create a partitioner which can be used across multiple partitioner filters
            </summary>
            <typeparam name="T"></typeparam>
            <param name="configurator"></param>
            <param name="partitionCount"></param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.PartitionerConfigurationExtensions.UsePartitioner``1(GreenPipes.IPipeConfigurator{``0},System.Int32,System.Func{``0,System.Guid})">
            <summary>
            Specify a concurrency limit for tasks executing through the filter. No more than the specified
            number of tasks will be allowed to execute concurrently.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="configurator"></param>
            <param name="partitionCount">The number of partitions to use when distributing message delivery</param>
            <param name="keyProvider">Provides the key from the message</param>
        </member>
        <member name="M:GreenPipes.PartitionerConfigurationExtensions.UsePartitioner``1(GreenPipes.IPipeConfigurator{``0},GreenPipes.Partitioning.IPartitioner,System.Func{``0,System.Guid})">
            <summary>
            Specify a concurrency limit for tasks executing through the filter. No more than the specified
            number of tasks will be allowed to execute concurrently.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="configurator"></param>
            <param name="partitioner">An existing partitioner that is shared</param>
            <param name="keyProvider">Provides the key from the message</param>
        </member>
        <member name="M:GreenPipes.PartitionerConfigurationExtensions.UsePartitioner``1(GreenPipes.IPipeConfigurator{``0},System.Int32,System.Func{``0,System.String},System.Text.Encoding)">
            <summary>
            Specify a concurrency limit for tasks executing through the filter. No more than the specified
            number of tasks will be allowed to execute concurrently.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="configurator"></param>
            <param name="partitionCount">The number of partitions to use when distributing message delivery</param>
            <param name="keyProvider">Provides the key from the message</param>
            <param name="encoding"></param>
        </member>
        <member name="M:GreenPipes.PartitionerConfigurationExtensions.UsePartitioner``1(GreenPipes.IPipeConfigurator{``0},GreenPipes.Partitioning.IPartitioner,System.Func{``0,System.String},System.Text.Encoding)">
            <summary>
            Specify a concurrency limit for tasks executing through the filter. No more than the specified
            number of tasks will be allowed to execute concurrently.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="configurator"></param>
            <param name="partitioner">An existing partitioner that is shared</param>
            <param name="keyProvider">Provides the key from the message</param>
            <param name="encoding"></param>
        </member>
        <member name="M:GreenPipes.PartitionerConfigurationExtensions.UsePartitioner``1(GreenPipes.IPipeConfigurator{``0},System.Int32,System.Func{``0,System.Int64})">
            <summary>
            Specify a concurrency limit for tasks executing through the filter. No more than the specified
            number of tasks will be allowed to execute concurrently.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="configurator"></param>
            <param name="partitionCount">The number of partitions to use when distributing message delivery</param>
            <param name="keyProvider">Provides the key from the message</param>
        </member>
        <member name="M:GreenPipes.PartitionerConfigurationExtensions.UsePartitioner``1(GreenPipes.IPipeConfigurator{``0},GreenPipes.Partitioning.IPartitioner,System.Func{``0,System.Int64})">
            <summary>
            Specify a concurrency limit for tasks executing through the filter. No more than the specified
            number of tasks will be allowed to execute concurrently.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="configurator"></param>
            <param name="partitioner">An existing partitioner that is shared</param>
            <param name="keyProvider">Provides the key from the message</param>
        </member>
        <member name="M:GreenPipes.PartitionerConfigurationExtensions.UsePartitioner``1(GreenPipes.IPipeConfigurator{``0},System.Int32,System.Func{``0,System.Byte[]})">
            <summary>
            Specify a concurrency limit for tasks executing through the filter. No more than the specified
            number of tasks will be allowed to execute concurrently.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="configurator"></param>
            <param name="partitionCount">The number of partitions to use when distributing message delivery</param>
            <param name="keyProvider">Provides the key from the message</param>
        </member>
        <member name="M:GreenPipes.PartitionerConfigurationExtensions.UsePartitioner``1(GreenPipes.IPipeConfigurator{``0},GreenPipes.Partitioning.IPartitioner,System.Func{``0,System.Byte[]})">
            <summary>
            Specify a concurrency limit for tasks executing through the filter. No more than the specified
            number of tasks will be allowed to execute concurrently.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="configurator"></param>
            <param name="partitioner">An existing partitioner that is shared</param>
            <param name="keyProvider">Provides the key from the message</param>
        </member>
        <member name="M:GreenPipes.RateLimitConfigurationExtensions.UseRateLimit``1(GreenPipes.IPipeConfigurator{``0},System.Int32,GreenPipes.IPipeRouter)">
            <summary>
            Specify a rate limit for message processing, so that only the specified number of messages are allowed
            per interval.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="configurator"></param>
            <param name="rateLimit">The number of messages allowed per interval</param>
            <param name="router">The control pipe used to adjust the rate limit dynamically</param>
        </member>
        <member name="M:GreenPipes.RateLimitConfigurationExtensions.UseRateLimit``1(GreenPipes.IPipeConfigurator{``0},System.Int32,System.TimeSpan,GreenPipes.IPipeRouter)">
            <summary>
            Specify a rate limit for message processing, so that only the specified number of messages are allowed
            per interval.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="configurator"></param>
            <param name="rateLimit">The number of messages allowed per interval</param>
            <param name="interval">The reset interval for each set of messages</param>
            <param name="router">The control pipe used to adjust the rate limit dynamically</param>
        </member>
        <member name="M:GreenPipes.RepeatPipeConfigurationExtensions.UseRepeat``1(GreenPipes.IPipeConfigurator{``0},System.Threading.CancellationToken)">
            <summary>
            Repeat the subsequent filter pipe until the cancellationToken is cancelled.
            </summary>
            <typeparam name="T">The pipe type</typeparam>
            <param name="configurator">The pipe configurator</param>
            <param name="cancellationToken">The cancellationToken to cancel the repetition</param>
        </member>
        <member name="M:GreenPipes.RequestConfigurationExtensions.CreateRequestPipe``1(GreenPipes.IPipe{GreenPipes.RequestContext},System.Func{GreenPipes.Configurators.IRequestConfigurator{``0},GreenPipes.IRequestPipe{``0}}[])">
            <summary>
            Creates a request pipe using an existing pipe
            </summary>
            <typeparam name="TRequest">The request type</typeparam>
            <param name="requestPipe">The pipe configurator</param>
            <param name="configureResults"></param>
        </member>
        <member name="M:GreenPipes.RequestConfigurationExtensions.CreateRequestPipe``2(GreenPipes.IPipe{GreenPipes.RequestContext},System.Action{GreenPipes.Configurators.IResultConfigurator{``0,``1}})">
            <summary>
            Creates a request pipe using an existing pipe
            </summary>
            <typeparam name="TRequest">The request type</typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="requestPipe">The pipe configurator</param>
            <param name="configure"></param>
        </member>
        <member name="M:GreenPipes.RequestConfigurationExtensions.Handle``1(GreenPipes.Configurators.IDispatchConfigurator{GreenPipes.RequestContext},System.Action{GreenPipes.IPipeConfigurator{GreenPipes.RequestContext{``0}}})">
            <summary>
            Handle the request on the dispatch pipeline
            </summary>
            <typeparam name="TRequest"></typeparam>
            <param name="configurator"></param>
            <param name="configure"></param>
        </member>
        <member name="M:GreenPipes.RescueConfigurationExtensions.UseRescue``2(GreenPipes.IPipeConfigurator{``0},GreenPipes.IPipe{``1},GreenPipes.Filters.RescueContextFactory{``0,``1},System.Action{GreenPipes.Configurators.IRescueConfigurator{``0,``1}})">
            <summary>
            Rescue exceptions via the alternate pipe
            </summary>
            <typeparam name="TContext"></typeparam>
            <typeparam name="TRescue"></typeparam>
            <param name="configurator"></param>
            <param name="rescuePipe"></param>
            <param name="rescueContextFactory">Factory method to convert the pipe context to the rescue pipe context</param>
            <param name="configure"></param>
        </member>
        <member name="M:GreenPipes.RescueConfigurationExtensions.UseRescue``2(GreenPipes.IPipeConfigurator{``0},GreenPipes.Filters.RescueContextFactory{``0,``1},System.Action{GreenPipes.Configurators.IRescueConfigurator{``0,``1}})">
            <summary>
            Adds a filter to the pipe which is of a different type than the native pipe context type
            </summary>
            <typeparam name="TContext">The context type</typeparam>
            <typeparam name="TRescue">The filter context type</typeparam>
            <param name="configurator">The pipe configurator</param>
            <param name="rescueContextFactory"></param>
            <param name="configure"></param>
        </member>
        <member name="M:GreenPipes.RetryConfigurationExtensions.None(GreenPipes.Configurators.IRetryConfigurator)">
            <summary>
            Create an immediate retry policy with the specified number of retries, with no
            delay between attempts.
            </summary>
            <param name="configurator"></param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.RetryConfigurationExtensions.Immediate(GreenPipes.Configurators.IRetryConfigurator,System.Int32)">
            <summary>
            Create an immediate retry policy with the specified number of retries, with no
            delay between attempts.
            </summary>
            <param name="configurator"></param>
            <param name="retryLimit">The number of retries to attempt</param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.RetryConfigurationExtensions.Intervals(GreenPipes.Configurators.IRetryConfigurator,System.TimeSpan[])">
            <summary>
            Create an interval retry policy with the specified intervals. The retry count equals
            the number of intervals provided
            </summary>
            <param name="configurator"></param>
            <param name="intervals">The intervals before each subsequent retry attempt</param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.RetryConfigurationExtensions.Intervals(GreenPipes.Configurators.IRetryConfigurator,System.Int32[])">
            <summary>
            Create an interval retry policy with the specified intervals. The retry count equals
            the number of intervals provided
            </summary>
            <param name="configurator"></param>
            <param name="intervals">The intervals before each subsequent retry attempt</param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.RetryConfigurationExtensions.Interval(GreenPipes.Configurators.IRetryConfigurator,System.Int32,System.TimeSpan)">
            <summary>
            Create an interval retry policy with the specified number of retries at a fixed interval
            </summary>
            <param name="configurator"></param>
            <param name="retryCount">The number of retry attempts</param>
            <param name="interval">The interval between each retry attempt</param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.RetryConfigurationExtensions.Interval(GreenPipes.Configurators.IRetryConfigurator,System.Int32,System.Int32)">
            <summary>
            Create an interval retry policy with the specified number of retries at a fixed interval
            </summary>
            <param name="configurator"></param>
            <param name="retryCount">The number of retry attempts</param>
            <param name="interval">The interval between each retry attempt</param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.RetryConfigurationExtensions.Exponential(GreenPipes.Configurators.IRetryConfigurator,System.Int32,System.TimeSpan,System.TimeSpan,System.TimeSpan)">
            <summary>
            Create an exponential retry policy with the specified number of retries at exponential
            intervals
            </summary>
            <param name="configurator"></param>
            <param name="retryLimit"></param>
            <param name="minInterval"></param>
            <param name="maxInterval"></param>
            <param name="intervalDelta"></param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.RetryConfigurationExtensions.Incremental(GreenPipes.Configurators.IRetryConfigurator,System.Int32,System.TimeSpan,System.TimeSpan)">
            <summary>
            Create an incremental retry policy with the specified number of retry attempts with an incrementing
            interval between retries
            </summary>
            <param name="configurator"></param>
            <param name="retryLimit">The number of retry attempts</param>
            <param name="initialInterval">The initial retry interval</param>
            <param name="intervalIncrement">The interval to add to the retry interval with each subsequent retry</param>
            <returns></returns>
        </member>
        <member name="T:GreenPipes.Specifications.ConcurrencyLimitPipeSpecification`1">
            <summary>
            Configures a concurrency limit on the pipe. If the management endpoint is specified,
            the consumer and appropriate mediator is created to handle the adjustment of the limit.
            </summary>
            <typeparam name="T">The message type being limited</typeparam>
        </member>
        <member name="T:GreenPipes.Specifications.FilterPipeSpecification`1">
            <summary>
            Adds an arbitrary filter to the pipe
            </summary>
            <typeparam name="TContext"></typeparam>
        </member>
        <member name="T:GreenPipes.Specifications.ForkPipeSpecification`1">
            <summary>
            Adds a fork to the pipe
            </summary>
            <typeparam name="TContext"></typeparam>
        </member>
        <member name="T:GreenPipes.Specifications.InlineFilterPipeSpecification`1">
            <summary>
            Adds an arbitrary filter to the pipe
            </summary>
            <typeparam name="TContext"></typeparam>
        </member>
        <member name="T:GreenPipes.Specifications.InterceptPipeSpecification`1">
            <summary>
            Adds a fork to the pipe
            </summary>
            <typeparam name="TContext"></typeparam>
        </member>
        <member name="T:GreenPipes.Specifications.SplitFilterPipeSpecification`2">
            <summary>
            Adds an arbitrary filter to the pipe
            </summary>
            <typeparam name="TContext"></typeparam>
            <typeparam name="TFilter">The filter type</typeparam>
        </member>
        <member name="T:GreenPipes.ValidationResult">
            <summary>
            Reports information about the configuration before configuring
            so that corrections can be made without allocating resources, etc.
            </summary>
        </member>
        <member name="P:GreenPipes.ValidationResult.Disposition">
            <summary>
            The disposition of the result, any Failure items will prevent
            the configuration from completing.
            </summary>
        </member>
        <member name="P:GreenPipes.ValidationResult.Message">
            <summary>
            The message associated with the result
            </summary>
        </member>
        <member name="P:GreenPipes.ValidationResult.Key">
            <summary>
            The key associated with the result (chained if configurators are nested)
            </summary>
        </member>
        <member name="P:GreenPipes.ValidationResult.Value">
            <summary>
            The value associated with the result
            </summary>
        </member>
        <member name="T:GreenPipes.ConnectHandle">
            <summary>
            A connect handle is returned by a non-asynchronous resource that supports
            disconnection (such as removing an observer, etc.)
            </summary>
        </member>
        <member name="M:GreenPipes.ConnectHandle.Disconnect">
            <summary>
            Explicitly disconnect the handle without waiting for it to be disposed. If the 
            connection is disconnected, the disconnect will be ignored when the handle is disposed.
            </summary>
        </member>
        <member name="P:GreenPipes.Contracts.CircuitBreakerOpened.Exception">
            <summary>
            The exception that caused the circuit breaker to open
            </summary>
        </member>
        <member name="P:GreenPipes.Contracts.CommandContext.Timestamp">
            <summary>
            The timestamp at which the command was sent
            </summary>
        </member>
        <member name="P:GreenPipes.Contracts.CommandContext`1.Command">
            <summary>
            The command object
            </summary>
        </member>
        <member name="P:GreenPipes.Contracts.EventContext.Timestamp">
            <summary>
            The timestamp at which the command was sent
            </summary>
        </member>
        <member name="P:GreenPipes.Contracts.EventContext`1.Event">
            <summary>
            The event object
            </summary>
        </member>
        <member name="T:GreenPipes.Contracts.ProfileData`1">
            <summary>
            Profiler data emitted for each occurrence
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:GreenPipes.Contracts.ProfileData`1.Context">
            <summary>
            The context for the profiled send
            </summary>
        </member>
        <member name="T:GreenPipes.Contracts.ProfileData">
            <summary>
            Profiler data emitted for each occurrence
            </summary>
        </member>
        <member name="P:GreenPipes.Contracts.SetConcurrencyLimit.ConcurrencyLimit">
            <summary>
            The new concurrency limit for the filter
            </summary>
        </member>
        <member name="T:GreenPipes.Contracts.SetRateLimit">
            <summary>
            Set the rate limit of the RateLimitFilter
            </summary>
        </member>
        <member name="P:GreenPipes.Contracts.SetRateLimit.RateLimit">
            <summary>
            The new rate limit for the filter
            </summary>
        </member>
        <member name="M:GreenPipes.Filters.CircuitBreaker.CircuitBreakerEventExtensions.PublishCircuitBreakerOpened(GreenPipes.IPipe{GreenPipes.Contracts.EventContext},System.Exception)">
            <summary>
            Set the concurrency limit of the filter
            </summary>
            <param name="pipe"></param>
            <param name="exception"></param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.Filters.CircuitBreaker.CircuitBreakerEventExtensions.PublishCircuitBreakerClosed(GreenPipes.IPipe{GreenPipes.Contracts.EventContext})">
            <summary>
            Set the concurrency limit of the filter
            </summary>
            <param name="pipe"></param>
            <returns></returns>
        </member>
        <member name="P:GreenPipes.Filters.CircuitBreaker.CircuitBreakerSettings.TrackingPeriod">
            <summary>
            The window duration to keep track of errors before they fall off the breaker state
            </summary>
        </member>
        <member name="P:GreenPipes.Filters.CircuitBreaker.CircuitBreakerSettings.ResetTimeout">
            <summary>
            The time to wait after the breaker has opened before attempting to close it
            </summary>
        </member>
        <member name="P:GreenPipes.Filters.CircuitBreaker.CircuitBreakerSettings.TripThreshold">
            <summary>
            A percentage of how many failures versus successful calls before the breaker
            is opened. Should be 0-100, but seriously like 5-10.
            </summary>
        </member>
        <member name="P:GreenPipes.Filters.CircuitBreaker.CircuitBreakerSettings.ActiveThreshold">
            <summary>
            The active count of attempts before the circuit breaker can be tripped
            </summary>
        </member>
        <member name="P:GreenPipes.Filters.CircuitBreaker.CircuitBreakerSettings.Router">
            <summary>
            The router used to publish events related to the circuit breaker behavior
            </summary>
        </member>
        <member name="T:GreenPipes.Filters.CircuitBreaker.ClosedBehavior">
            <summary>
            Represents a closed, normally operating circuit breaker state
            </summary>
        </member>
        <member name="T:GreenPipes.Filters.CircuitBreaker.HalfOpenBehavior">
            <summary>
            Executes until the success count is met. If a fault occurs before the success 
            count is reached, the circuit reopens.
            </summary>
        </member>
        <member name="T:GreenPipes.Filters.CircuitBreaker.ICircuitBreaker">
            <summary>
            Provides access to a circuit breaker from a state object
            </summary>
        </member>
        <member name="P:GreenPipes.Filters.CircuitBreaker.ICircuitBreaker.TripThreshold">
            <summary>
            The number of failures before opening the circuit breaker
            </summary>
        </member>
        <member name="P:GreenPipes.Filters.CircuitBreaker.ICircuitBreaker.ActiveThreshold">
            <summary>
            The minimum number of attempts before the breaker can possibly trip
            </summary>
        </member>
        <member name="P:GreenPipes.Filters.CircuitBreaker.ICircuitBreaker.OpenDuration">
            <summary>
            Window duration before attempt/success/failure counts are reset
            </summary>
        </member>
        <member name="M:GreenPipes.Filters.CircuitBreaker.ICircuitBreaker.Open(System.Exception,GreenPipes.Filters.CircuitBreaker.ICircuitBreakerBehavior,System.Collections.Generic.IEnumerator{System.TimeSpan})">
            <summary>
            Open the circuit breaker, preventing any further access to the resource until
            the timer expires
            </summary>
            <param name="exception">The exception to return when the circuit breaker is accessed</param>
            <param name="behavior"></param>
            <param name="timeoutEnumerator">A previously created enumerator for a timeout period</param>
        </member>
        <member name="M:GreenPipes.Filters.CircuitBreaker.ICircuitBreaker.ClosePartially(System.Exception,System.Collections.Generic.IEnumerator{System.TimeSpan},GreenPipes.Filters.CircuitBreaker.ICircuitBreakerBehavior)">
            <summary>
            Partially open the circuit breaker, allowing the eventual return to a closed
            state
            </summary>
            <param name="exception"></param>
            <param name="timeoutEnumerator"></param>
            <param name="behavior"></param>
        </member>
        <member name="M:GreenPipes.Filters.CircuitBreaker.ICircuitBreaker.Close(GreenPipes.Filters.CircuitBreaker.ICircuitBreakerBehavior)">
            <summary>
            Close the circuit breaker, allowing normal execution
            </summary>
            <param name="behavior"></param>
        </member>
        <member name="T:GreenPipes.Filters.CircuitBreaker.OpenBehavior">
            <summary>
            Represents a circuit that is unavailable, with a timer waiting to partially close
            the circuit.
            </summary>
        </member>
        <member name="T:GreenPipes.Filters.ConcurrencyLimitFilter`1">
            <summary>
            Limits the concurrency of the next section of the pipeline based on the concurrency limit
            specified.
            </summary>
            <typeparam name="TContext"></typeparam>
        </member>
        <member name="M:GreenPipes.Filters.ConcurrencyLimitFilter`1.WaitForRunningTasks(System.Threading.CancellationToken)">
            <summary>
            A hack, but waits for any tasks that have been sent through the filter to complete by
            waiting and taking all the concurrent slots
            </summary>
            <param name="cancellationToken">Of course we can cancel the operation</param>
            <returns></returns>
        </member>
        <member name="T:GreenPipes.Filters.ContextFilter`1">
            <summary>
            A content filter applies a delegate to the message context, and uses the result to either accept the message
            or discard it.
            </summary>
            <typeparam name="TContext"></typeparam>
        </member>
        <member name="T:GreenPipes.Filters.DynamicFilter`1">
            <summary>
            Dispatches an inbound pipe to one or more output pipes based on a dispatch
            type.
            </summary>
            <typeparam name="TInput"></typeparam>
        </member>
        <member name="T:GreenPipes.Filters.ForkFilter`1">
            <summary>
            Forks a single pipe into two pipes, which are executed concurrently
            </summary>
            <typeparam name="TContext"></typeparam>
        </member>
        <member name="T:GreenPipes.Filters.InterceptFilter`1">
            <summary>
            Intercepts the pipe and executes an adjacent pipe prior to executing the next filter in the main pipe
            </summary>
            <typeparam name="TContext"></typeparam>
        </member>
        <member name="T:GreenPipes.Filters.IPipeContextConverter`2">
            <summary>
            Converts the input context to the output context
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
        </member>
        <member name="M:GreenPipes.Filters.IPipeContextConverterFactory`1.GetConverter``1">
            <summary>
            Given a known input context type, convert it to the correct output 
            context type.
            </summary>
            <typeparam name="TOutput"></typeparam>
            <returns></returns>
        </member>
        <member name="T:GreenPipes.Filters.KeyFilter`2">
            <summary>
            Handles the registration of requests and connecting them to the consume pipe
            </summary>
            <typeparam name="TContext"></typeparam>
            <typeparam name="TKey"></typeparam>
        </member>
        <member name="T:GreenPipes.Filters.OutputPipeFilter`2">
            <summary>
            Converts an inbound context type to a pipe context type post-dispatch
            </summary>
            <typeparam name="TInput">The pipe context type</typeparam>
            <typeparam name="TOutput">The subsequent pipe context type</typeparam>
        </member>
        <member name="T:GreenPipes.Filters.RateLimitFilter`1">
            <summary>
            Limits the number of calls through the filter to a specified count per time interval
            specified.
            </summary>
            <typeparam name="TContext"></typeparam>
        </member>
        <member name="T:GreenPipes.Filters.RepeatFilter`1">
            <summary>
            Uses a retry policy to handle exceptions, retrying the operation in according
            with the policy
            </summary>
            <typeparam name="TContext"></typeparam>
        </member>
        <member name="T:GreenPipes.Filters.RescueFilter`2">
            <summary>
            Rescue catches an exception, and if the exception matches the exception filter,
            passes control to the rescue pipe.
            </summary>
            <typeparam name="TContext">The cotext type</typeparam>
            <typeparam name="TRescueContext"></typeparam>
        </member>
        <member name="T:GreenPipes.Filters.RetryFilter`1">
            <summary>
            Uses a retry policy to handle exceptions, retrying the operation in according
            with the policy
            </summary>
        </member>
        <member name="T:GreenPipes.Filters.TeeFilter`1">
            <summary>
            Connects multiple output pipes to a single input pipe
            </summary>
            <typeparam name="TContext"></typeparam>
        </member>
        <member name="T:GreenPipes.Filters.TeeFilter`2">
            <summary>
            Connects multiple output pipes to a single input pipe
            </summary>
            <typeparam name="TContext"></typeparam>
            <typeparam name="TKey">The key type</typeparam>
        </member>
        <member name="T:GreenPipes.IDynamicRouter`1">
            <summary>
            A dynamic router is a pipe on which additional pipes can be connected and context is 
            routed through the pipe based upon the output requirements of the connected pipes. It is built
            around the dynamic filter, which is the central point of the router.
            </summary>
        </member>
        <member name="T:GreenPipes.IDynamicRouter`2">
            <summary>
            A dynamic router is a pipe on which additional pipes can be connected and context is 
            routed through the pipe based upon the output requirements of the connected pipes. It is built
            around the dynamic filter, which is the central point of the router.
            </summary>
        </member>
        <member name="T:GreenPipes.IExceptionFilter">
            <summary>
            Filter exceptions for policies that act based on an exception
            </summary>
        </member>
        <member name="M:GreenPipes.IExceptionFilter.Match(System.Exception)">
            <summary>
            Returns true if the exception matches the filter and the policy should
            be applied to the exception.
            </summary>
            <param name="exception">The exception</param>
            <returns>True if the exception matches the filter, otherwise false.</returns>
        </member>
        <member name="T:GreenPipes.IFilter`1">
            <summary>
            A filter is a functional node in a pipeline, connected by pipes to
            other filters.
            </summary>
            <typeparam name="TContext">The pipe context type</typeparam>
        </member>
        <member name="M:GreenPipes.IFilter`1.Send(`0,GreenPipes.IPipe{`0})">
            <summary>
            Sends a context to a filter, such that it can be processed and then passed to the
            specified output pipe for further processing.
            </summary>
            <param name="context">The pipe context type</param>
            <param name="next">The next pipe in the pipeline</param>
            <returns>An awaitable Task</returns>
        </member>
        <member name="M:GreenPipes.IFilterObserver.PreSend``1(``0)">
            <summary>
            Called before a message is dispatched to any consumers
            </summary>
            <param name="context">The consume context</param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.IFilterObserver.PostSend``1(``0)">
            <summary>
            Called after the message has been dispatched to all consumers - note that in the case of an exception
            this method is not called, and the DispatchFaulted method is called instead
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.IFilterObserver.SendFault``1(``0,System.Exception)">
            <summary>
            Called after the message has been dispatched to all consumers when one or more exceptions have occurred
            </summary>
            <param name="context"></param>
            <param name="exception"></param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.IFilterObserver`1.PreSend(`0)">
            <summary>
            Called before a message is dispatched to any consumers
            </summary>
            <param name="context">The consume context</param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.IFilterObserver`1.PostSend(`0)">
            <summary>
            Called after the message has been dispatched to all consumers - note that in the case of an exception
            this method is not called, and the DispatchFaulted method is called instead
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.IFilterObserver`1.SendFault(`0,System.Exception)">
            <summary>
            Called after the message has been dispatched to all consumers when one or more exceptions have occurred
            </summary>
            <param name="context"></param>
            <param name="exception"></param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.Internals.Extensions.ExpressionExtensions.GetMemberName``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Gets the name of the member specified
            </summary>
            <typeparam name="T">The type referenced</typeparam>
            <typeparam name="TMember">The type of the member referenced</typeparam>
            <param name="expression">The expression referencing the member</param>
            <returns>The name of the member referenced by the expression</returns>
        </member>
        <member name="M:GreenPipes.Internals.Extensions.ExpressionExtensions.GetMemberName``1(System.Linq.Expressions.Expression{System.Action{``0}})">
            <summary>
            Gets the name of the member specified
            </summary>
            <typeparam name="T">The type referenced</typeparam>
            <param name="expression">The expression referencing the member</param>
            <returns>The name of the member referenced by the expression</returns>
        </member>
        <member name="M:GreenPipes.Internals.Extensions.TypeExtensions.IsConcrete(System.Type)">
            <summary>
            Determines if a type is neither abstract nor an interface and can be constructed.
            </summary>
            <param name="type">The type to check</param>
            <returns>True if the type can be constructed, otherwise false.</returns>
        </member>
        <member name="M:GreenPipes.Internals.Extensions.TypeExtensions.IsConcreteAndAssignableTo(System.Type,System.Type)">
            <summary>
            Determines if a type can be constructed, and if it can, additionally determines
            if the type can be assigned to the specified type.
            </summary>
            <param name="type">The type to evaluate</param>
            <param name="assignableType">The type to which the subject type should be checked against</param>
            <returns>True if the type is concrete and can be assigned to the assignableType, otherwise false.</returns>
        </member>
        <member name="M:GreenPipes.Internals.Extensions.TypeExtensions.IsConcreteAndAssignableTo``1(System.Type)">
            <summary>
            Determines if a type can be constructed, and if it can, additionally determines
            if the type can be assigned to the specified type.
            </summary>
            <param name="type">The type to evaluate</param>
            <typeparam name="T">The type to which the subject type should be checked against</typeparam>
            <returns>True if the type is concrete and can be assigned to the assignableType, otherwise false.</returns>
        </member>
        <member name="M:GreenPipes.Internals.Extensions.TypeExtensions.IsNullable(System.Type)">
            <summary>
            Determines if the type is a nullable type
            </summary>
            <param name="type">The type</param>
            <returns>True if the type can be null</returns>
        </member>
        <member name="M:GreenPipes.Internals.Extensions.TypeExtensions.IsNullable(System.Type,System.Type@)">
            <summary>
            Determines if the type is a nullable type
            </summary>
            <param name="type">The type</param>
            <param name="underlyingType">The underlying type of the nullable</param>
            <returns>True if the type can be null</returns>
        </member>
        <member name="M:GreenPipes.Internals.Extensions.TypeExtensions.IsOpenGeneric(System.Type)">
            <summary>
            Determines if the type is an open generic with at least one unspecified generic argument
            </summary>
            <param name="type">The type</param>
            <returns>True if the type is an open generic</returns>
        </member>
        <member name="M:GreenPipes.Internals.Extensions.TypeExtensions.CanBeNull(System.Type)">
            <summary>
            Determines if a type can be null
            </summary>
            <param name="type">The type</param>
            <returns>True if the type can be null</returns>
        </member>
        <member name="M:GreenPipes.Internals.Extensions.TypeExtensions.GetTypeName(System.Type)">
            <summary>
            Returns an easy-to-read type name from the specified Type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.Internals.Extensions.TypeExtensions.GetAttribute``1(System.Reflection.ICustomAttributeProvider)">
            <summary>
            Returns the first attribute of the specified type for the object specified
            </summary>
            <typeparam name="T">The type of attribute</typeparam>
            <param name="provider">An attribute provider, which can be a MethodInfo, PropertyInfo, Type, etc.</param>
            <returns>The attribute instance if found, or null</returns>
        </member>
        <member name="M:GreenPipes.Internals.Extensions.TypeExtensions.HasAttribute``1(System.Reflection.ICustomAttributeProvider)">
            <summary>
            Determines if the target has the specified attribute
            </summary>
            <typeparam name="T"></typeparam>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.Internals.Extensions.TypeExtensions.IsAnonymousType(System.Type)">
            <summary>
            Returns true if the type is an anonymous type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.Internals.Extensions.TypeExtensions.IsInNamespace(System.Type,System.String)">
            <summary>
            Returns true if the type is contained within the namespace
            </summary>
            <param name="type"></param>
            <param name="nameSpace"></param>
            <returns></returns>
        </member>
        <member name="T:GreenPipes.Internals.Mapping.DictionaryConverterCache">
            <summary>
            Caches the type converter instances
            </summary>
        </member>
        <member name="T:GreenPipes.Internals.Mapping.DynamicObjectConverterCache">
            <summary>
            Caches dictionary to object converters for the types requested, including the implementation
            builder for interfaces that are dynamically proxied
            </summary>
        </member>
        <member name="P:GreenPipes.Introspection.ProbeHostInfo.MachineName">
            <summary>
            The machine name (or role instance name) of the local machine
            </summary>
        </member>
        <member name="P:GreenPipes.Introspection.ProbeHostInfo.ProcessName">
            <summary>
            The process name hosting the routing slip activity
            </summary>
        </member>
        <member name="P:GreenPipes.Introspection.ProbeHostInfo.ProcessId">
            <summary>
            The processId of the hosting process
            </summary>
        </member>
        <member name="P:GreenPipes.Introspection.ProbeHostInfo.Assembly">
            <summary>
            The assembly where the exception occurred
            </summary>
        </member>
        <member name="P:GreenPipes.Introspection.ProbeHostInfo.AssemblyVersion">
            <summary>
            The assembly version of the assembly where the exception occurred
            </summary>
        </member>
        <member name="P:GreenPipes.Introspection.ProbeHostInfo.FrameworkVersion">
            <summary>
            The .NET framework version
            </summary>
        </member>
        <member name="P:GreenPipes.Introspection.ProbeHostInfo.GreenPipesVersion">
            <summary>
            The version of MassTransit used by the process
            </summary>
        </member>
        <member name="P:GreenPipes.Introspection.ProbeHostInfo.OperatingSystemVersion">
            <summary>
            The operating system version hosting the application
            </summary>
        </member>
        <member name="T:GreenPipes.Introspection.ProbeResult">
            <summary>
            The result of a probe
            </summary>
        </member>
        <member name="P:GreenPipes.Introspection.ProbeResult.ResultId">
            <summary>
            Unique identifies this result
            </summary>
        </member>
        <member name="P:GreenPipes.Introspection.ProbeResult.ProbeId">
            <summary>
            Identifies the initiator of the probe
            </summary>
        </member>
        <member name="P:GreenPipes.Introspection.ProbeResult.StartTimestamp">
            <summary>
            When the probe was initiated through the system
            </summary>
        </member>
        <member name="P:GreenPipes.Introspection.ProbeResult.Duration">
            <summary>
            How long the probe took to execute
            </summary>
        </member>
        <member name="P:GreenPipes.Introspection.ProbeResult.Host">
            <summary>
            The host from which the result was generated
            </summary>
        </member>
        <member name="P:GreenPipes.Introspection.ProbeResult.Results">
            <summary>
            The results returned by the probe
            </summary>
        </member>
        <member name="M:GreenPipes.IObserverConnector.ConnectObserver``1(GreenPipes.IFilterObserver{``0})">
            <summary>
            Connect an observer to the filter and/or pipe
            </summary>
            <param name="observer"></param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.IObserverConnector.ConnectObserver(GreenPipes.IFilterObserver)">
            <summary>
            Connect an observer to the filter and/or pipe
            </summary>
            <param name="observer"></param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.IObserverConnector`1.ConnectObserver(GreenPipes.IFilterObserver{`0})">
            <summary>
            Connect an observer to the filter and/or pipe
            </summary>
            <param name="observer"></param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.IPipe`1.Send(`0)">
            <summary>
            The base primitive, Send delivers the pipe context of T to the pipe.
            </summary>
            <param name="context">The pipe context of type T</param>
            <returns>A task which is completed once the pipe has processed the context</returns>
        </member>
        <member name="T:GreenPipes.IPipeConnector">
            <summary>
            The intent is to connect a pipe of a specific type to a pipe of a different type,
            for which there is a provider that knows how to convert the input type to the output type.
            </summary>
        </member>
        <member name="M:GreenPipes.IPipeConnector.ConnectPipe``1(GreenPipes.IPipe{``0})">
            <summary>
            Connect a pipe of the specified type to the DispatchFilter
            </summary>
            <typeparam name="T"></typeparam>
            <param name="pipe"></param>
            <returns></returns>
        </member>
        <member name="T:GreenPipes.IPipeConnector`1">
            <summary>
            Connect a pipe of the same type as the target pipe
            </summary>
            <typeparam name="TContext"></typeparam>
        </member>
        <member name="T:GreenPipes.IKeyPipeConnector`1">
            <summary>
            Supports connecting a pipe using a key, which is a method of dispatching to different pipes
            based on context.
            </summary>
            <typeparam name="TKey"></typeparam>
        </member>
        <member name="M:GreenPipes.IKeyPipeConnector`1.ConnectPipe``1(`0,GreenPipes.IPipe{``0})">
            <summary>
            Connect a pipe to the filter using the specified key
            </summary>
            <param name="key"></param>
            <param name="pipe"></param>
            <returns></returns>
        </member>
        <member name="T:GreenPipes.IProbeSite">
            <summary>
            To support the introspection of code, this interface is used to gain
            information about the bus.
            </summary>
        </member>
        <member name="M:GreenPipes.IRequestPipe`1.Send(`0)">
            <summary>
            Send a request to the pipe
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:GreenPipes.IRequestPipe`2">
            <summary>
            A request pipe which allows awaiting a specific response
            </summary>
            <typeparam name="TRequest"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:GreenPipes.IRequestPipe`2.Send(`0)">
            <summary>
            Send a request to the pipe
            </summary>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.IRetryObserver.PostCreate``1(GreenPipes.RetryPolicyContext{``0})">
            <summary>
            Called before a message is dispatched to any consumers
            </summary>
            <param name="context">The consume context</param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.IRetryObserver.PostFault``1(GreenPipes.RetryContext{``0})">
            <summary>
            Called after a fault has occurred, but will be retried
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.IRetryObserver.PreRetry``1(GreenPipes.RetryContext{``0})">
            <summary>
            Called immediately before an exception will be retried
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.IRetryObserver.RetryFault``1(GreenPipes.RetryContext{``0})">
            <summary>
            Called when the retry filter is no longer going to retry, and the context is faulted.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.IRetryObserverConnector.ConnectRetryObserver(GreenPipes.IRetryObserver)">
            <summary>
            Connect an observer to the filter and/or pipe
            </summary>
            <param name="observer"></param>
            <returns></returns>
        </member>
        <member name="T:GreenPipes.IRetryPolicy">
            <summary>
            A retry policy determines how exceptions are handled, and whether or not the
            remaining filters should be retried
            </summary>
        </member>
        <member name="M:GreenPipes.IRetryPolicy.CreatePolicyContext``1(``0)">
            <summary>
            Creates a retry policy context for the retry, which initiates the exception tracking
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.IRetryPolicy.IsHandled(System.Exception)">
            <summary>
            If the retry policy handles the exception, should return true
            </summary>
            <param name="exception"></param>
            <returns></returns>
        </member>
        <member name="T:GreenPipes.ITargetFilter`1">
            <summary>
            Allows a context to be merged into an arbitrary context
            </summary>
            <typeparam name="TTarget"></typeparam>
        </member>
        <member name="T:GreenPipes.Partitioning.IHashGenerator">
            <summary>
            Generates a hash of the input data for partitioning purposes
            </summary>
        </member>
        <member name="M:GreenPipes.Partitioning.IPartitioner`1.Send(`0,GreenPipes.IPipe{`0})">
            <summary>
            Sends the context through the partitioner
            </summary>
            <param name="context">The context</param>
            <param name="next">The next pipe</param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.Partitioning.Partition.WaitForRunningTasks(System.Threading.CancellationToken)">
            <summary>
            A hack, but waits for any tasks that have been sent through the filter to complete by
            waiting and taking all the concurrent slots
            </summary>
            <param name="cancellationToken">Of course we can cancel the operation</param>
            <returns></returns>
        </member>
        <member name="T:GreenPipes.Payloads.IPayloadCache">
            <summary>
            The context properties
            </summary>
        </member>
        <member name="M:GreenPipes.Payloads.IPayloadCache.GetOrAddPayload``1(GreenPipes.PayloadFactory{``0})">
            <summary>
            Return an existing or create a new property
            </summary>
            <param name="payloadFactory"></param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.Payloads.IPayloadCache.CreateScope">
            <summary>
            Returns a scope from the current cache state
            </summary>
            <returns></returns>
        </member>
        <member name="T:GreenPipes.Payloads.IPayloadCollection">
            <summary>
            Supports the reading and writing of the property cache
            </summary>
        </member>
        <member name="T:GreenPipes.Payloads.IPayloadValue">
            <summary>
            A property is a value stored in the context, which can be accessed by name or
            by type. This is the actual property storage element
            </summary>
        </member>
        <member name="P:GreenPipes.Payloads.IPayloadValue.ValueType">
            <summary>
            The property value type
            </summary>
        </member>
        <member name="M:GreenPipes.Payloads.IPayloadValue.TryGetValue``1(``0@)">
            <summary>
            Returns the value if it can be assigned to the specified type
            </summary>
            <typeparam name="T">The requested type</typeparam>
            <param name="value">The output value</param>
            <returns></returns>
        </member>
        <member name="T:GreenPipes.Payloads.IPayloadValue`1">
            <summary>
            A property value with the generic type applied
            </summary>
            <typeparam name="TPayload"></typeparam>
        </member>
        <member name="P:GreenPipes.Payloads.IPayloadValue`1.Value">
            <summary>
            The value of the property, already assigned to T
            </summary>
        </member>
        <member name="T:GreenPipes.Payloads.IReadOnlyPayloadCollection">
            <summary>
            Supports the reading of the property cache
            </summary>
        </member>
        <member name="M:GreenPipes.Payloads.IReadOnlyPayloadCollection.HasPayloadType(System.Type)">
            <summary>
            Checks if the property exists in the cache
            </summary>
            <param name="payloadType">The property type</param>
            <returns>True if the property exists in the cache, otherwise false</returns>
        </member>
        <member name="M:GreenPipes.Payloads.IReadOnlyPayloadCollection.TryGetPayload``1(``0@)">
            <summary>
            Returns the value of the property if it exists in the cache
            </summary>
            <typeparam name="TPayload">The property type</typeparam>
            <param name="payload">The property value</param>
            <returns>True if the value was returned, otherwise false</returns>
        </member>
        <member name="T:GreenPipes.Payloads.PayloadValue`1">
            <summary>
            Stores a single scope data value
            </summary>
            <typeparam name="TPayload"></typeparam>
        </member>
        <member name="M:GreenPipes.Pipe.New``1(System.Action{GreenPipes.IPipeConfigurator{``0}})">
            <summary>
            Create a new pipe using the pipe configurator to add filters, etc.
            </summary>
            <typeparam name="T">The pipe context type</typeparam>
            <param name="callback">The configuration callback</param>
            <returns>An initialized pipe ready for use</returns>
        </member>
        <member name="M:GreenPipes.Pipe.Execute``1(System.Action{``0})">
            <summary>
            Constructs a simple pipe that executes the specified action
            </summary>
            <typeparam name="T">The pipe context type</typeparam>
            <param name="action">The method to execute</param>
            <returns>The constructed pipe</returns>
        </member>
        <member name="M:GreenPipes.Pipe.ExecuteAsync``1(System.Func{``0,System.Threading.Tasks.Task})">
            <summary>
            Constructs a simple pipe that executes the specified action
            </summary>
            <typeparam name="T">The pipe context type</typeparam>
            <param name="action">The method to execute</param>
            <returns>The constructed pipe</returns>
        </member>
        <member name="M:GreenPipes.Pipe.Empty``1">
            <summary>
            Returns an empty pipe of the specified context type
            </summary>
            <typeparam name="T">The context type</typeparam>
            <returns></returns>
        </member>
        <member name="T:GreenPipes.PipeContext">
            <summary>
            The base context for all pipe types, includes the payload sidebanding of data
            with the payload, as well as the cancellationToken to avoid passing it everywhere
            </summary>
        </member>
        <member name="P:GreenPipes.PipeContext.CancellationToken">
            <summary>
            Used to cancel the execution of the context
            </summary>
        </member>
        <member name="M:GreenPipes.PipeContext.HasPayloadType(System.Type)">
            <summary>
            Checks if a payload is present in the context
            </summary>
            <param name="payloadType"></param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.PipeContext.TryGetPayload``1(``0@)">
            <summary>
            Retrieves a payload from the pipe context
            </summary>
            <typeparam name="TPayload">The payload type</typeparam>
            <param name="payload">The payload</param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.PipeContext.GetOrAddPayload``1(GreenPipes.PayloadFactory{``0})">
            <summary>
            Returns an existing payload or creates the payload using the factory method provided
            </summary>
            <typeparam name="TPayload">The payload type</typeparam>
            <param name="payloadFactory">The payload factory is the payload is not present</param>
            <returns>The payload</returns>
        </member>
        <member name="M:GreenPipes.PipeExtensions.GetPayload``1(GreenPipes.PipeContext)">
            <summary>
            Get a payload from the pipe context
            </summary>
            <typeparam name="TPayload">The payload type</typeparam>
            <param name="context">The pipe context</param>
            <returns>The payload, or throws a PayloadNotFoundException if the payload is not present</returns>
        </member>
        <member name="T:GreenPipes.Pipes.DynamicRouter`1">
            <summary>
            A dynamic router is a pipe on which additional pipes can be connected and context is 
            routed through the pipe based upon the output requirements of the connected pipes. It is built
            around the dynamic filter, which is the central point of the router.
            </summary>
        </member>
        <member name="T:GreenPipes.Pipes.LastPipe`1">
            <summary>
            The last pipe in a pipeline is always an end pipe that does nothing and returns synchronously
            </summary>
            <typeparam name="TContext"></typeparam>
        </member>
        <member name="T:GreenPipes.Pipes.MultipleResultRequestPipe`1">
            <summary>
            A pipe for a single request with multiple result types
            </summary>
            <typeparam name="TRequest"></typeparam>
        </member>
        <member name="T:GreenPipes.Pipes.SingleResultRequestPipe`2">
            <summary>
            A pipe for a single request with a single result type. Simplifies everything.
            </summary>
            <typeparam name="TRequest"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="T:GreenPipes.ProbeContext">
            <summary>
            Passed to a probe site to inspect it for interesting things
            </summary>
        </member>
        <member name="P:GreenPipes.ProbeContext.CancellationToken">
            <summary>
            If for some reason the probe is cancelled, allowing an early withdrawl
            </summary>
        </member>
        <member name="M:GreenPipes.ProbeContext.Add(System.String,System.String)">
            <summary>
            Add a key/value pair to the current probe context
            </summary>
            <param name="key">The key name</param>
            <param name="value">The value</param>
        </member>
        <member name="M:GreenPipes.ProbeContext.Add(System.String,System.Object)">
            <summary>
            Add a key/value pair to the current probe context
            </summary>
            <param name="key">The key name</param>
            <param name="value">The value</param>
        </member>
        <member name="M:GreenPipes.ProbeContext.Set(System.Object)">
            <summary>
            Add the properties of the object as key/value pairs to the current context
            </summary>
            <param name="values">The object (typically anonymous with new{}</param>
        </member>
        <member name="M:GreenPipes.ProbeContext.Set(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
            <summary>
            Add the values from the enumeration as key/value pairs
            </summary>
            <param name="values"></param>
        </member>
        <member name="P:GreenPipes.RequestContext.IsCompleted">
            <summary>
            True if the request has been completed and a result specified
            </summary>
        </member>
        <member name="M:GreenPipes.RequestContext.TrySetResult``1(``0)">
            <summary>
            Attempt to specify a result for the request
            </summary>
            <typeparam name="T">The result type</typeparam>
            <param name="result">The result</param>
            <returns>True if the response was accepted, false if a response was already accepted</returns>
        </member>
        <member name="M:GreenPipes.RequestContext.TrySetException(System.Exception)">
            <summary>
            Specify that the request faulted and will have an exception
            </summary>
            <param name="exception"></param>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.RequestContext.TrySetCanceled">
            <summary>
            Specify that the request was cancelled
            </summary>
            <returns></returns>
        </member>
        <member name="T:GreenPipes.RequestContext`1">
            <summary>
            The context of a request sent to a pipe
            </summary>
            <typeparam name="TRequest"></typeparam>
        </member>
        <member name="P:GreenPipes.RequestContext`1.Request">
            <summary>
            The request type that was sent to the pipe
            </summary>
        </member>
        <member name="T:GreenPipes.ResultContext">
            <summary>
            The response context
            </summary>
        </member>
        <member name="M:GreenPipes.ResultContext.GetResult``1">
            <summary>
            Returns the result type specified, if it is available
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:GreenPipes.ResultContext.TryGetResult``1(``0@)">
            <summary>
            Returns the result type specified if matched, otherwise returns false
            </summary>
            <typeparam name="T"></typeparam>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:GreenPipes.ResultContext`2">
            <summary>
            A response context combined a request with the applied response
            </summary>
            <typeparam name="TRequest"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="P:GreenPipes.RetryContext.RetryAttempt">
            <summary>
            The retry attempt currently being attempted
            </summary>
        </member>
        <member name="P:GreenPipes.RetryContext.ContextType">
            <summary>
            The context type of the retry context
            </summary>
        </member>
        <member name="P:GreenPipes.RetryContext`1.Exception">
            <summary>
            The exception that originally caused the retry to be initiated
            </summary>
        </member>
        <member name="P:GreenPipes.RetryContext`1.RetryCount">
            <summary>
            The number of retries which were attempted beyond the initial attempt
            </summary>
        </member>
        <member name="P:GreenPipes.RetryContext`1.Delay">
            <summary>
            The time to wait before the next retry attempt
            </summary>
        </member>
        <member name="M:GreenPipes.RetryContext`1.PreRetry">
            <summary>
            Called before the retry attempt is performed
            </summary>
            <returns></returns>
        </member>
        <member name="T:GreenPipes.RetryPolicyContext`1">
            <summary>
            An initial context acquired to begin a retry filter
            </summary>
            <typeparam name="TContext"></typeparam>
        </member>
        <member name="P:GreenPipes.RetryPolicyContext`1.Context">
            <summary>
            The context being managed by the retry policy
            </summary>
        </member>
        <member name="M:GreenPipes.RetryPolicyContext`1.CanRetry(System.Exception,GreenPipes.RetryContext{`0}@)">
            <summary>
            Determines if the exception can be retried
            </summary>
            <param name="exception">The exception that occurred</param>
            <param name="retryContext">The retry context for the retry</param>
            <returns>True if the task should be retried</returns>
        </member>
        <member name="M:GreenPipes.RetryPolicyContext`1.RetryFaulted(System.Exception)">
            <summary>
            Called after the retry attempt has failed
            </summary>
            <param name="exception"></param>
            <returns></returns>
        </member>
        <member name="T:GreenPipes.Util.Connectable`1">
            <summary>
            Maintains a collection of connections of the generic type
            </summary>
            <typeparam name="T">The connectable type</typeparam>
        </member>
        <member name="P:GreenPipes.Util.Connectable`1.Count">
            <summary>
            The number of connections
            </summary>
        </member>
        <member name="M:GreenPipes.Util.Connectable`1.Connect(`0)">
            <summary>
            Connect a connectable type
            </summary>
            <param name="connection">The connection to add</param>
            <returns>The connection handle</returns>
        </member>
        <member name="M:GreenPipes.Util.Connectable`1.ForEachAsync(System.Func{`0,System.Threading.Tasks.Task})">
            <summary>
            Enumerate the connections invoking the callback for each connection
            </summary>
            <param name="callback">The callback</param>
            <returns>An awaitable Task for the operation</returns>
        </member>
    </members>
</doc>
